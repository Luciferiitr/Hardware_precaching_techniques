%%%%%%%%%%%%  Generated using docx2latex.com  %%%%%%%%%%%%%%

%%%%%%%%%%%%  v2.0.0-beta  %%%%%%%%%%%%%%

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage[normalem]{ulem}
\usepackage{array}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[backend=biber,
style=numeric,
sorting=none,
isbn=false,
doi=false,
url=false,
]{biblatex}\addbibresource{bibliography.bib}

\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{wasysym}
\usepackage{enumitem}
\usepackage{adjustbox}
\usepackage{ragged2e}
\usepackage[svgnames,table]{xcolor}
\usepackage{tikz}
\usepackage{longtable}
\usepackage{changepage}
\usepackage{setspace}
\usepackage{hhline}
\usepackage{multicol}
\usepackage{tabto}
\usepackage{float}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{fancyhdr}
\usepackage[toc,page]{appendix}
\usepackage[hidelinks]{hyperref}
\usetikzlibrary{shapes.symbols,shapes.geometric,shadows,arrows.meta}
\tikzset{>={Latex[width=1.5mm,length=2mm]}}
\usepackage{flowchart}\usepackage[paperheight=11.69in,paperwidth=8.27in,left=0.79in,right=0.79in,top=0.79in,bottom=0.79in,headheight=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\TabPositions{0.5in,1.0in,1.5in,2.0in,2.5in,3.0in,3.5in,4.0in,4.5in,5.0in,5.5in,6.0in,6.5in,}

\urlstyle{same}


 %%%%%%%%%%%%  Set Depths for Sections  %%%%%%%%%%%%%%

% 1) Section
% 1.1) SubSection
% 1.1.1) SubSubSection
% 1.1.1.1) Paragraph
% 1.1.1.1.1) Subparagraph


\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}


 %%%%%%%%%%%%  Set Depths for Nested Lists created by \begin{enumerate}  %%%%%%%%%%%%%%


\setlistdepth{9}
\renewlist{enumerate}{enumerate}{9}
		\setlist[enumerate,1]{label=\arabic*)}
		\setlist[enumerate,2]{label=\alph*)}
		\setlist[enumerate,3]{label=(\roman*)}
		\setlist[enumerate,4]{label=(\arabic*)}
		\setlist[enumerate,5]{label=(\Alph*)}
		\setlist[enumerate,6]{label=(\Roman*)}
		\setlist[enumerate,7]{label=\arabic*}
		\setlist[enumerate,8]{label=\alph*}
		\setlist[enumerate,9]{label=\roman*}

\renewlist{itemize}{itemize}{9}
		\setlist[itemize]{label=$\cdot$}
		\setlist[itemize,1]{label=\textbullet}
		\setlist[itemize,2]{label=$\circ$}
		\setlist[itemize,3]{label=$\ast$}
		\setlist[itemize,4]{label=$\dagger$}
		\setlist[itemize,5]{label=$\triangleright$}
		\setlist[itemize,6]{label=$\bigstar$}
		\setlist[itemize,7]{label=$\blacklozenge$}
		\setlist[itemize,8]{label=$\prime$}

\setlength{\topsep}{0pt}\setlength{\parindent}{0pt}
\renewcommand{\arraystretch}{1.3}


%%%%%%%%%%%%%%%%%%%% Document code starts here %%%%%%%%%%%%%%%%%%%%



\begin{document}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}
{\fontsize{32pt}{38.4pt}\selectfont \textbf{Hardware Prefetching Techniques}\par}\par


\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}
{\fontsize{18pt}{21.6pt}\selectfont \textbf{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Team Members:-}\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \textbf{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  }\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \textbf{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Computer Science and Engineering:-}\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  1. Ashish Ucheniya (18114014)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  2. Devjit Menghani (18119010)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  3. Ishan Pandey (18113061)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  4. Unmesh Kumar (18114079)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  5. Vamsi GVK (18114023)\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textbf{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Electronics and Communication Engineering:-}\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  1. Nunsavath Prashanth (18116056)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  2. Nagulapati Sainath (18116050)\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  3. Allu Vamsi Vishal (18116007)\par}\par


\vspace{\baselineskip}
{\fontsize{20pt}{24.0pt}\selectfont \textbf{Description of topic}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont In recent years, microprocessors’ execution speed has improved rapidly, but memory access time has improved in much slower rate. Consequently, microprocessor performance has been affected by the much slower memory access. Microprocessors waste multiple clock cycles waiting for data availability from the memory. Cache memories were added to microprocessor architecture to overcome this deficiency. Cache improvement is limited to the hit and miss rate. Prefetching mechanism improves cache usage efficiency. Using an effective prefetching technique may improve cache hit rate significantly. In this project, we focus on some hardware prefetching techniques.\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Cache prefetching boosts execution performance by fetching instructions or data from their original storage in slower memory to a faster local memory before it is actually needed (hence the term 'prefetch'). Most modern computer processors have fast and local cache memory in which prefetched data is held until it is required. The source for the prefetch operation is usually main memory. Because of their design, accessing cache memories is typically much faster than accessing main memory, so prefetching data and then accessing it from caches is usually many orders of magnitude faster than accessing it directly from main memory.}\par}\par


\vspace{\baselineskip}
{\fontsize{20pt}{24.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{Why the topic is interesting/important?}}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Cache prefetching, if implemented properly with proper prefetching algorithm,}\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{can incredibly increase performance upto 50$\%$ . Being a very simple technique, }\par}\par

{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{it can save lots of cache misses boosting processing speed is what makes it interesting as well as important for performance of modern computers.}\par}\par


\vspace{\baselineskip}
{\fontsize{20pt}{24.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{References}}\par}\par


\vspace{\baselineskip}
\begin{enumerate}[label*={\fontsize{15pt}{15pt}\selectfont \arabic*.}]
	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Steven P. Vanderweil and David J.Lilja. Data Prefetching Mechanisms.ACM Computing Surveys, Vol 32, No 2, June 2000}\par}\par

	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Mittal, Sparsh (2016-08-01). \href{https://zenodo.org/record/1236174}{"A Survey of Recent Prefetching Techniques for Processor Caches"}. \textit{ACM Comput. Surv}. 49 (2): 35:1–35:35. doi:\href{https://doi.org/10.1145%2F2907071}{10.1145/2907071}. ISSN\colorbox{Blue}{ \href{https://www.worldcat.org/issn/0360-0300}{}0360-0300}.}\par}\par

	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Palacharla, S.; Kessler, R. E. (1994-01-01). \textit{Evaluating Stream Buffers As a Secondary Cache Replacement}. 21st Annual International Symposium on Computer Architecture. Chicago, IL, USA: IEEE Computer Society Press. pp. 24–33. \href{https://en.wikipedia.org/wiki/CiteSeerX}{}CiteSeerX}\textcolor[HTML]{0B0080}{ 1\href{https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.92.3031}{}0.1.1.92.3031}. \href{https://en.wikipedia.org/wiki/Digital_object_identifier}{doi}}:\href{https://doi.org/10.1145%2F191995.192014}{10.1145/191995.192014}(inactive 2019-02-19). \href{https://en.wikipedia.org/wiki/International_Standard_Book_Number}{}ISBN}\textcolor[HTML]{0B0080}{ \href{https://en.wikipedia.org/wiki/Special:BookSources/978-0818655104}{}}978-0818655104}\textcolor[HTML]{222222}{.}\par}
\end{enumerate}\par


\vspace{\baselineskip}
{\fontsize{20pt}{24.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{Description of hardware prefetching techniques}}\par}\par


\vspace{\baselineskip}
{\fontsize{18pt}{21.6pt}\selectfont \textbf{\textcolor[HTML]{222222}{1. Sequential prefetching}}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{This method utilizes the principle of spatial locality to prefetch data that is likely to be referenced in the near future. The processor fetches number of memory locations called cache block each time accesses the cache. The simplest \textbf{Sequential Prefetching} schemes are based on the \textbf{one block lookahead approach(OBL)}. This approach prefetches block n+1, when block n is accessed. There are several different OBL approaches depending on what type of access to block n triggers the Prefetch of n+1. We discuss three approaches:}\par}\par


\vspace{\baselineskip}
\begin{itemize}
	\item {\fontsize{16pt}{19.2pt}\selectfont \textbf{\textcolor[HTML]{222222}{Prefetch-on-miss}}\par}\par

\begin{enumerate}
	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{The Prefetch-on-miss scheme simply prefetches block n+1 whenever block n is accessed as a result of a cache miss. If n+1 is already cached, no memory access is initiated. This algorithm is effective whenever a cache miss occurs. Since this scheme requires a cache miss prior to Prefetch, it is only effective less than $\%$ 50.}\par}\par


\vspace{\baselineskip}
	\item {\fontsize{16pt}{19.2pt}\selectfont \textbf{\textcolor[HTML]{222222}{Tagged Prefetch}}\par}\par

	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{The Tagged Prefetch algorithm assigns a tag bit to every memory block. The tag bit is utilized to detect when a block is demand-fetched or prefetched block is referenced for the first time. In both cases, the next sequential block is fetched. Since this algorithm does not require a cache miss to trigger Prefetch, it is more effective.}\par}\par


\vspace{\baselineskip}
	\item {\fontsize{15pt}{18.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{Sequential Prefetch with K=2, where K is the degree of prefetching }}\par}
\end{enumerate}\par

	\item {\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{It is possible to increase the number of demand fetch from 1 to K, K is degree of prefetching. Upon memory access to block n, blocks n+1 to n+K are prefetched. K is chosen empirically and is highly depending on the degree of spatial locality. For small K result may be insufficient performance improvement, and for large K cache pollution may occur. Ideally, an adaptive Sequential Prefetching must allow K to vary during program execution.}\par}
\end{itemize}\par


\vspace{\baselineskip}
{\fontsize{18pt}{21.6pt}\selectfont \textbf{\textcolor[HTML]{222222}{2. Stream buffers}}\par}\par


\vspace{\baselineskip}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 1 starts here %%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
	\begin{Center}
		\includegraphics[width=0.02in,height=0.02in]{./media/image1.png}
	\end{Center}
\end{figure}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 1 Ends here %%%%%%%%%%%%%%%%%%%%

{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{Stream buffers were developed based on the concept of one block lookahead (OBL). Stream buffers are one of the most common hardware based prefetching techniques in use. The basic idea is that the cache miss address (and k subsequent addresses) are fetched into a separate buffer of depth k. This buffer is called a stream buffer and is separate from cache. The processor then consumes data/instructions from the stream buffer if the address associated with the prefetched blocks match the requested address generated by the program executing on the processor. The figure below illustrates this setup:}\par}\par


\vspace{\baselineskip}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 2 starts here %%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
	\begin{Center}
		\includegraphics[width=3.35in,height=2.77in]{./media/image2.png}
	\end{Center}
\end{figure}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 2 Ends here %%%%%%%%%%%%%%%%%%%%

\par


\vspace{\baselineskip}
{\fontsize{18pt}{21.6pt}\selectfont \textbf{\textcolor[HTML]{222222}{3. Stride prefetching}}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont The simplest way for prefetch hardware to identify a strided array referencing pattern also called stride prefetching is to explicitly declare when such a pattern occurs within the program and then pass this information on to the hardware. This is possible when programs are explicitly vectorized so that computation is described as a series of vector and matrix operations by the programmer, as is commonly done when programming machines which contain vector processors.\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textbf{Advantages of this prefetching technique}:-\par}\par

{\fontsize{15pt}{18.0pt}\selectfont To be effective, a prefetch mechanism must perform well for the most common types of memory referencing patterns. Scalar and\textbf{ unit-stride }array references typically dominate in most applications and prefetching mechanisms should capture this type of access pattern. Sequential prefetching techniques concentrate exclusively on these access patterns. Although comparatively infrequent, large stride array referencing patterns can result in very poor cache utilization. RPT mechanisms sacrifice some scalar performance in order to cover strided referencing patterns. \par}\par

{\fontsize{15pt}{18.0pt}\selectfont In the case of \textbf{prefetch-on-miss}, prefetching is suppressed when a large stride is specified by the instruction. This avoids useless prefetches, which degraded the performance of the original policy. Although vector prefetching does issue prefetches for large stride referencing patterns, it is a more precise mechanism than other sequential schemes because it is able to take advantage of stride information provided by the program.\par}\par



%%%%%%%%%%%%%%%%%%%% Figure/Image No: 3 starts here %%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
	\begin{Center}
		\includegraphics[width=4.89in,height=3.67in]{./media/image3.png}
	\end{Center}
\end{figure}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 3 Ends here %%%%%%%%%%%%%%%%%%%%

\par


\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}

\vspace{\baselineskip}
{\fontsize{20pt}{24.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{GANTT Chart}}\par}\par



%%%%%%%%%%%%%%%%%%%% Figure/Image No: 4 starts here %%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
\advance\leftskip 0.17in		\includegraphics[width=6.69in,height=2.8in]{./media/image4.png}
\end{figure}


%%%%%%%%%%%%%%%%%%%% Figure/Image No: 4 Ends here %%%%%%%%%%%%%%%%%%%%

\par

{\fontsize{20pt}{24.0pt}\selectfont \textbf{\textcolor[HTML]{222222}{Result and Discussion}}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{From the three hardware based prefetching methods discussed in this report, the first and second one is effective in applications where there is an address stream regularities which could be captured by an\ arithmetic formula  (eg. A constant stride between sequentially accessed memory locations). Stride prefetching takes advantage of strided array referencing pattern of processor to anticipate data that will be fetched in future.}\par}\par


\vspace{\baselineskip}
{\fontsize{15pt}{18.0pt}\selectfont \textcolor[HTML]{222222}{There are other hardware prefetching techniques developed recently such as }Hardware Based Pointer Data Prefetcher and Dependence\ Based Prefetching for Linked Data Structures (LDS)  which we have not covered in this report. Their study and work remain as future work.\par}\par


\printbibliography
\end{document}